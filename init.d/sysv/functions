# init script functions library for desktop linux systems

[ -n "$ZAPRET_BASE" ] || ZAPRET_BASE=/opt/zapret
. "$ZAPRET_BASE/config"
. "$ZAPRET_BASE/common/base.sh"
. "$ZAPRET_BASE/common/fwtype.sh"
. "$ZAPRET_BASE/common/queue.sh"
. "$ZAPRET_BASE/common/linux_iphelper.sh"
. "$ZAPRET_BASE/common/ipt.sh"
. "$ZAPRET_BASE/common/nft.sh"
. "$ZAPRET_BASE/common/linux_fw.sh"


user_exists()
{
	id -u $1 >/dev/null 2>/dev/null
}
useradd_compat()
{
	# $1 - username

	# skip for readonly systems
	[ -w "/etc" ] && {
		if exists useradd ; then
			useradd --no-create-home --system --shell /bin/false $1
		elif is_linked_to_busybox adduser ; then
			# busybox has special adduser syntax
			adduser -S -H -D $1
		elif exists adduser; then
			adduser --no-create-home --system --disabled-login $1
		fi
	}
	user_exists $1
}
prepare_user()
{
	# $WS_USER is required to prevent redirection of the traffic originating from TPWS itself
	# otherwise infinite loop will occur
	# also its good idea not to run tpws as root
	user_exists $WS_USER || {
		# fallback to daemon if we cant add WS_USER
		useradd_compat $WS_USER || {
			for user in daemon nobody; do
				user_exists $user && {
					WS_USER=$user
					return 0
				}
			done
			return 1
		}
	}
}

# this complex user selection allows to survive in any locked/readonly/minimalistic environment
[ -n "$WS_USER" ] || WS_USER=tpws
if prepare_user; then
 USEROPT="--user=$WS_USER"
else
 WS_USER=1
 USEROPT="--uid $WS_USER:$WS_USER"
fi

PIDDIR=/var/run
IPSET_CR="$ZAPRET_BASE/ipset/create_ipset.sh"

[ -n "$QNUM" ] || QNUM=200
[ -n "$NFQWS" ] || NFQWS="$ZAPRET_BASE/nfq/nfqws"
NFQWS_OPT_BASE="$USEROPT --dpi-desync-fwmark=$DESYNC_MARK"
NFQWS_OPT_DESYNC_HTTP="${NFQWS_OPT_DESYNC_HTTP:-$NFQWS_OPT_DESYNC}"
NFQWS_OPT_DESYNC_HTTPS="${NFQWS_OPT_DESYNC_HTTPS:-$NFQWS_OPT_DESYNC}"
NFQWS_OPT_DESYNC_HTTP6="${NFQWS_OPT_DESYNC_HTTP6:-$NFQWS_OPT_DESYNC_HTTP}"
NFQWS_OPT_DESYNC_HTTPS6="${NFQWS_OPT_DESYNC_HTTPS6:-$NFQWS_OPT_DESYNC_HTTPS}"

[ -n "$TPPORT" ] || TPPORT=988
[ -n "$TPWS" ] || TPWS="$ZAPRET_BASE/tpws/tpws"
TPWS_LOCALHOST4=127.0.0.127
HOSTLIST="$ZAPRET_BASE/ipset/zapret-hosts.txt.gz"
[ -f "$HOSTLIST" ] || HOSTLIST="$ZAPRET_BASE/ipset/zapret-hosts.txt"
[ -f "$HOSTLIST" ] || HOSTLIST="$ZAPRET_BASE/ipset/zapret-hosts-user.txt"

TPWS_OPT_BASE="$USEROPT"
TPWS_OPT_BASE4="--bind-addr=$TPWS_LOCALHOST4"
TPWS_OPT_BASE6="--bind-addr=::1"
TPWS_WAIT="--bind-wait-ifup=30 --bind-wait-ip=30"
TPWS_WAIT_SOCKS6="$TPWS_WAIT --bind-wait-ip-linklocal=30"
# first wait for lan to ifup, then wait for bind-wait-ip-linklocal seconds for link local address and bind-wait-ip for any ipv6 as the worst case
TPWS_OPT_BASE6_PRE="--bind-linklocal=prefer $TPWS_WAIT --bind-wait-ip-linklocal=3"

[ -n "$DESYNC_MARK" ] || DESYNC_MARK=0x40000000

# max wait time for the link local ipv6 on the LAN interface
LINKLOCAL_WAIT_SEC=5

CUSTOM_SCRIPT="$ZAPRET_BASE/init.d/sysv/custom"
[ -f "$CUSTOM_SCRIPT" ] && . "$CUSTOM_SCRIPT"

IPSET_EXCLUDE="-m set ! --match-set nozapret"
IPSET_EXCLUDE6="-m set ! --match-set nozapret6"


# there's no route_localnet for ipv6
# the best we can is to route to link local of the incoming interface
# OUTPUT - can DNAT to ::1
# PREROUTING - can't DNAT to ::1. can DNAT to link local of -i interface or to any global addr
# not a good idea to expose tpws to the world (bind to ::)

dnat6_target()
{
	# $1 - lan network name
	# $2 - var to store target ip6
	# get target ip address for DNAT. prefer link locals
	# tpws should be as inaccessible from outside as possible
	# link local address can appear not immediately after ifup
	# DNAT6_TARGET=- means attempt was made but address was not found (to avoid multiple re-attempts)

	local DNAT6_TARGET DVAR=DNAT6_TARGET_$1
	DVAR=$(echo $DVAR | sed 's/[^a-zA-Z0-9_]/_/g')
	eval DNAT6_TARGET="\$$DVAR"
	[ -n "$2" ] && eval $2=''
	[ -n "$DNAT6_TARGET" ] || {
		local ct=0
		while
			DNAT6_TARGET=$(get_ipv6_linklocal $1)
			[ -n "$DNAT6_TARGET" ] && break
			[ "$ct" -ge "$LINKLOCAL_WAIT_SEC" ] && break
			echo $1: waiting for the link local for another $(($LINKLOCAL_WAIT_SEC - $ct)) seconds ...
			ct=$(($ct+1))
			sleep 1
		do :; done

		[ -n "$DNAT6_TARGET" ] || {
		    	echo $1: no link local. getting global
			DNAT6_TARGET=$(get_ipv6_global $1)
			[ -n "$DNAT6_TARGET" ] || {
				echo $1: could not get any address
				DNAT6_TARGET=-
			}
		}
		eval $DVAR="$DNAT6_TARGET"
	}
	[ -n "$2" ] && eval $2="$DNAT6_TARGET"
}

set_route_localnet()
{
	# $1 - 1 = enable, 0 = disable

	[ "$DISABLE_IPV4" = "1" ] || {
		local lan
		for lan in $IFACE_LAN ; do
			sysctl -q -w net.ipv4.conf.$lan.route_localnet=$1
		done
	}
}
prepare_route_localnet()
{
	set_route_localnet 1
}
unprepare_route_localnet()
{
	set_route_localnet 0
}
prepare_tpws_fw4()
{
	# otherwise linux kernel will treat 127.0.0.0/8 as "martian" ip and refuse routing to it
	# NOTE : kernels <3.6 do not have this feature. consider upgrading or change DNAT to REDIRECT and do not bind to 127.0.0.0/8
	[ "$DISABLE_IPV4" = "1" ] || {
		[ -n "$IFACE_LAN" ] && {
			local lan
			iptables -N input_rule_zapret 2>/dev/null
			iptables -F input_rule_zapret
			iptables -A input_rule_zapret -d $TPWS_LOCALHOST4 -j RETURN
			iptables -A input_rule_zapret -d 127.0.0.0/8 -j DROP
			ipt INPUT ! -i lo -j input_rule_zapret
			prepare_route_localnet
		}
	}
}
unprepare_tpws_fw4()
{
	[ "$DISABLE_IPV4" = "1" ] || {
		[ -n "$IFACE_LAN" ] && {
			local lan
			unprepare_route_localnet
			ipt_del INPUT ! -i lo -j input_rule_zapret
			iptables -F input_rule_zapret 2>/dev/null
			iptables -X input_rule_zapret 2>/dev/null
		}
	}
}
unprepare_tpws_fw()
{
	unprepare_tpws_fw4
}


ipt_print_op()
{
	if [ "$1" = "1" ]; then
		echo "Adding ip$4tables rule for $3 : $2"
	else
		echo "Deleting ip$4tables rule for $3 : $2"
	fi
}

fw_tpws4()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv4
	# $3 - tpws port
	[ "$DISABLE_IPV4" = "1" ] || {
		[ "$1" = 1 ] && prepare_tpws_fw4
		ipt_print_op $1 "$2" "tpws (port $3)"
		for lan in $IFACE_LAN ; do
			ipt_add_del $1 PREROUTING -t nat -i $lan -p tcp $2 $IPSET_EXCLUDE dst -j DNAT --to $TPWS_LOCALHOST4:$3
	 	done
		if [ -n "$IFACE_WAN" ]; then
			for wan in $IFACE_WAN; do
				ipt_add_del $1 OUTPUT -t nat -o $wan -m owner ! --uid-owner $WS_USER -p tcp $2 $IPSET_EXCLUDE dst -j DNAT --to $TPWS_LOCALHOST4:$3
			done
		else
			ipt_add_del $1 OUTPUT -t nat -m owner ! --uid-owner $WS_USER -p tcp $2 $IPSET_EXCLUDE dst -j DNAT --to $TPWS_LOCALHOST4:$3
		fi
	}
}
fw_tpws6()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv6
	# $3 - tpws port
	[ "$DISABLE_IPV6" = "1" ] || {
		ipt_print_op $1 "$2" "tpws (port $3)" 6
		local DNAT6
		for lan in $IFACE_LAN ; do
			dnat6_target $lan DNAT6
			[ "$DNAT6" != "-" ] && ipt6_add_del $1 PREROUTING -t nat -i $lan -p tcp $2 $IPSET_EXCLUDE6 dst -j DNAT --to [$DNAT6]:$3
	 	done
		if [ -n "$IFACE_WAN" ]; then
			for wan in $IFACE_WAN; do
				ipt6_add_del $1 OUTPUT -t nat -o $wan -m owner ! --uid-owner $WS_USER -p tcp $2 $IPSET_EXCLUDE6 dst -j DNAT --to [::1]:$3
			done
		else
			ipt6_add_del $1 OUTPUT -t nat -m owner ! --uid-owner $WS_USER -p tcp $2 $IPSET_EXCLUDE6 dst -j DNAT --to [::1]:$3
		fi
	}
}
fw_tpws()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv4
	# $3 - iptable filter for ipv6
	# $4 - tpws port
	fw_tpws4 $1 "$2" $4
	fw_tpws6 $1 "$3" $4
}


fw_nfqws_pre4()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv4
	# $3 - queue number
	[ "$DISABLE_IPV4" = "1" ] || {
		ipt_print_op $1 "$2" "nfqws prerouting (qnum $3)"
		if [ -n "$IFACE_WAN" ]; then
			for wan in $IFACE_WAN; do
				ipt_add_del $1 PREROUTING -t mangle -i $wan -p tcp $2 $IPSET_EXCLUDE src -j NFQUEUE --queue-num $3 --queue-bypass
			done
		else
				ipt_add_del $1 PREROUTING -t mangle -p tcp $2 $IPSET_EXCLUDE src -j NFQUEUE --queue-num $3 --queue-bypass
		fi
	}
}
fw_nfqws_pre6()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv6
	# $3 - queue number
	[ "$DISABLE_IPV6" = "1" ] || {
		ipt_print_op $1 "$2" "nfqws prerouting (qnum $3)" 6
		if [ -n "$IFACE_WAN" ]; then
			for wan in $IFACE_WAN; do
				ipt6_add_del $1 PREROUTING -t mangle -i $wan -p tcp $2 $IPSET_EXCLUDE6 src -j NFQUEUE --queue-num $3 --queue-bypass
			done
		else
			ipt6_add_del $1 PREROUTING -t mangle -p tcp $2 $IPSET_EXCLUDE6 src -j NFQUEUE --queue-num $3 --queue-bypass
		fi
	}
}
fw_nfqws_pre()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv4
	# $3 - iptable filter for ipv6
	# $4 - queue number
	fw_nfqws_pre4 $1 "$2" $4
	fw_nfqws_pre6 $1 "$3" $4
}
fw_nfqws_post4()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv4
	# $3 - queue number
	[ "$DISABLE_IPV4" = "1" ] || {
		ipt_print_op $1 "$2" "nfqws postrouting (qnum $3)"
		if [ -n "$IFACE_WAN" ]; then
			for wan in $IFACE_WAN; do
				ipt_add_del $1 POSTROUTING -t mangle -o $wan -p tcp $2 $IPSET_EXCLUDE dst -j NFQUEUE --queue-num $3 --queue-bypass
			done
		else
			ipt_add_del $1 POSTROUTING -t mangle -p tcp $2 $IPSET_EXCLUDE dst -j NFQUEUE --queue-num $3 --queue-bypass
		fi
	}
}
fw_nfqws_post6()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv6
	# $3 - queue number
	[ "$DISABLE_IPV6" = "1" ] || {
		ipt_print_op $1 "$2" "nfqws postrouting (qnum $3)" 6
		if [ -n "$IFACE_WAN" ]; then
			for wan in $IFACE_WAN; do
				ipt6_add_del $1 POSTROUTING -t mangle -o $wan -p tcp $2 $IPSET_EXCLUDE6 dst -j NFQUEUE --queue-num $3 --queue-bypass
			done
		else
			ipt6_add_del $1 POSTROUTING -t mangle -p tcp $2 $IPSET_EXCLUDE6 dst -j NFQUEUE --queue-num $3 --queue-bypass
		fi
	}
}
fw_nfqws_post()
{
	# $1 - 1 - add, 0 - del
	# $2 - iptable filter for ipv4
	# $3 - iptable filter for ipv6
	# $4 - queue number
	fw_nfqws_post4 $1 "$2" $4
	fw_nfqws_post6 $1 "$3" $4
}

filter_apply_hostlist_target()
{
	# $1 - var name of tpws or nfqws params
	[ "$MODE_FILTER" = "hostlist" ] && eval $1="\"\$$1 --hostlist=$HOSTLIST\""
}

run_daemon()
{
	# $1 - daemon number : 1,2,3,...
	# $2 - daemon
	# $3 - daemon args
	# use $PIDDIR/$DAEMONBASE$1.pid as pidfile

	local DAEMONBASE=$(basename $2)
	local PIDFILE=$PIDDIR/$DAEMONBASE$1.pid
	echo "Starting daemon $1: $2 $3"
	if exists start-stop-daemon ; then
		start-stop-daemon -S -p "$PIDFILE" -m -b -x "$2" -- $3
	else
		if [ -f "$PIDFILE" ] && pgrep -F "$PIDFILE" "$DAEMONBASE" >/dev/null; then
			echo already running
		else
			"$2" $3 >/dev/null 2>/dev/null &
			PID=$!
			if [ -n "$PID" ]; then
				echo $PID >$PIDFILE
			else
				echo could not start daemon $1 : $2 $3
				false
			fi
		fi
	fi
}
stop_daemon()
{
	# $1 - daemon number : 1,2,3,...
	# $2 - daemon
	# use $PIDDIR/$DAEMONBASE$1.pid as pidfile
	local DAEMONBASE=$(basename $2)
	local PIDFILE=$PIDDIR/$DAEMONBASE$1.pid
	echo "Stopping daemon $1: $2"
	if exists start-stop-daemon ; then
		start-stop-daemon -K -p "$PIDFILE" -x "$2"
	else
		if [ -f "$PIDFILE" ]; then
			read PID <"$PIDFILE"
			kill $PID
			rm -f "$PIDFILE"
		else
			echo no pidfile : $PIDFILE
		fi
	fi
}
do_daemon()
{
	# $1 - 1 - run, 0 - stop
	on_off_function run_daemon stop_daemon "$@"
}


do_tpws()
{
	# $1 : 1 - run, 0 - stop
	# $2 : daemon number
	# $3 : daemon args

	[ "$DISABLE_IPV4" = "1" ] && [ "$DISABLE_IPV6" = "1" ] && return 0

	local OPT="$TPWS_OPT_BASE"

	[ "$DISABLE_IPV4" = "1" ] || OPT="$OPT $TPWS_OPT_BASE4"
	[ "$DISABLE_IPV6" = "1" ] || {
		OPT="$OPT $TPWS_OPT_BASE6"
		for lan in $IFACE_LAN; do
			OPT="$OPT --bind-iface6=$lan $TPWS_OPT_BASE6_PRE"
		done
	}

	do_daemon $1 $2 "$TPWS" "$OPT $3"
}
do_tpws_socks()
{
	# $1 : 1 - run, 0 - stop
	# $2 : daemon number
	# $3 : daemon args

	[ "$DISABLE_IPV4" = "1" ] && [ "$DISABLE_IPV6" = "1" ] && return 0

	local opt="$TPWS_OPT_BASE --socks"

	tpws_apply_socks_binds opt

	do_daemon $1 $2 "$TPWS" "$opt $3"
}

do_nfqws()
{
	# $1 : 1 - run, 0 - stop
	# $2 : daemon number
	# $3 : daemon args

	do_daemon $1 $2 "$NFQWS" "$NFQWS_OPT_BASE $3"
}

tpws_apply_socks_binds()
{
	local o

	[ "$DISABLE_IPV4" = "1" ] || o="--bind-addr=127.0.0.1"
	[ "$DISABLE_IPV6" = "1" ] || o="$o --bind-addr=::1"
	
	for lan in $IFACE_LAN; do
	    [ "$DISABLE_IPV4" = "1" ] || o="$o --bind-iface4=$lan $TPWS_WAIT"
	    [ "$DISABLE_IPV6" = "1" ] || o="$o --bind-iface6=$lan --bind-linklocal=unwanted $TPWS_WAIT_SOCKS6"
	done
	eval $1="\"\$$1 $o\""
}


create_ipset()
{
	echo "Creating ip list table (firewall type $FWTYPE)"
	"$IPSET_CR" "$@"
}


zapret_do_daemons()
{
	# $1 - 1 - run, 0 - stop

	local opt qn qns qn6 qns6

	case "${MODE_OVERRIDE:-$MODE}" in
		tpws)
			opt="--port=$TPPORT $TPWS_OPT"
			filter_apply_hostlist_target opt
			do_tpws $1 1 "$opt"
			;;
		tpws-socks)
			opt="--port=$TPPORT $TPWS_OPT"
			filter_apply_hostlist_target opt
			do_tpws_socks $1 1 "$opt"
			;;
		nfqws)
			get_nfqws_qnums qn qns qn6 qns6
			[ -z "$qn" ] || {
				opt="--qnum=$qn $NFQWS_OPT_DESYNC_HTTP"
				filter_apply_hostlist_target opt
				do_nfqws $1 1 "$opt"
			}
			[ -z "$qns" ] || [ "$qns" = "$qn" ] || {
				opt="--qnum=$qns $NFQWS_OPT_DESYNC_HTTPS"
				filter_apply_hostlist_target opt
				do_nfqws $1 2 "$opt"
			}
			[ -z "$qn6" ] || [ "$qn6" = "$qn" ] || [ "$qn6" = "$qns" ] || {
				opt="--qnum=$qn6 $NFQWS_OPT_DESYNC_HTTP6"
				filter_apply_hostlist_target opt
				do_nfqws $1 3 "$opt"
			}
			[ -z "$qns6" ] || [ "$qns6" = "$qn" ] || [ "$qns6" = "$qns" ] || [ "$qns6" = "$qn6" ] || {
				opt="--qnum=$qns6 $NFQWS_OPT_DESYNC_HTTPS6"
				filter_apply_hostlist_target opt
				do_nfqws $1 4 "$opt"
			}
			;;
		custom)
	    		existf zapret_custom_daemons && zapret_custom_daemons $1
			;;
	esac

	return 0
}
zapret_run_daemons()
{
	zapret_do_daemons 1 "$@"
}
zapret_stop_daemons()
{
	zapret_do_daemons 0 "$@"
}


nft_fill_ifsets_overload()
{
	nft_fill_ifsets "$IFACE_LAN" "$IFACE_WAN" "$IFACE_WAN"
}

nft_print_op()
{
	echo "Adding nftables ipv$3 rule for $2 : $1"
}

nft_fw_tpws4()
{
	# $1 - filter ipv4
	# $2 - tpws port

	[ "$DISABLE_IPV4" = "1" ] || {
		nft_print_op "$1" "tpws (port $2)" 4
		nft_add_rule dnat_output skuid != $WS_USER ${IFACE_WAN:+oifname @wanif }meta l4proto tcp $1 ip daddr != @nozapret dnat ip to $TPWS_LOCALHOST4:$2
		[ -n "$IFACE_LAN" ] && {
			prepare_route_localnet
			nft_add_rule dnat_pre iifname @lanif meta l4proto tcp $1 ip daddr != @nozapret dnat ip to $TPWS_LOCALHOST4:$2
		}
	}
}
nft_fw_tpws6()
{
	# $1 - filter ipv6
	# $2 - tpws port

	local lan DNAT6
	[ "$DISABLE_IPV6" = "1" ] || {
		nft_print_op "$1" "tpws (port $2)" 6
		nft_add_rule dnat_output skuid != $WS_USER ${IFACE_WAN:+oifname @wanif6 }meta l4proto tcp $1 ip6 daddr != @nozapret6 dnat ip6 to [::1]:$2
		for lan in $IFACE_LAN ; do
			dnat6_target $lan DNAT6
			[ "$DNAT6" != '-' ] && nft_add_rule dnat_pre iifname $lan meta l4proto tcp $1 ip6 daddr != @nozapret6 dnat ip6 to [$DNAT6]:$2
		done
	}
}
nft_fw_tpws()
{
	# $1 - filter ipv4
	# $2 - filter ipv6
	# $3 - tpws port

	nft_fw_tpws4 "$1" $3
	nft_fw_tpws6 "$2" $3
}

nft_fw_nfqws_post4()
{
	# $1 - filter ipv4
	# $2 - queue number

	local rule

	[ "$DISABLE_IPV4" = "1" ] || {
		nft_print_op "$1" "nfqws postrouting (qnum $2)" 4
		rule="${IFACE_WAN:+oifname @wanif }meta l4proto tcp $1 ip daddr != @nozapret"
		nft_add_rule postrouting $rule queue num $2 bypass
		nft_add_nfqws_flow_exempt_rule "$rule"
	}
}
nft_fw_nfqws_post6()
{
	# $1 - filter ipv6
	# $2 - queue number

	local rule

	[ "$DISABLE_IPV6" = "1" ] || {
		nft_print_op "$1" "nfqws postrouting (qnum $2)" 6
		rule="${IFACE_WAN:+oifname @wanif6 }meta l4proto tcp $1 ip6 daddr != @nozapret6"
		nft_add_rule postrouting $rule queue num $2 bypass
		nft_add_nfqws_flow_exempt_rule "$rule"
	}
}
nft_fw_nfqws_post()
{
	# $1 - filter ipv4
	# $2 - filter ipv6
	# $3 - queue number

	nft_fw_nfqws_post4 "$1" $3
	nft_fw_nfqws_post6 "$2" $3
}
