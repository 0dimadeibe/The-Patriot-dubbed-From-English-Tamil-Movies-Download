. /lib/functions/network.sh

[ -n "$ZAPRET_BASE" ] || ZAPRET_BASE=/opt/zapret
. "$ZAPRET_BASE/config"
. "$ZAPRET_BASE/common/base.sh"
. "$ZAPRET_BASE/common/fwtype.sh"
. "$ZAPRET_BASE/common/queue.sh"
. "$ZAPRET_BASE/common/linux_iphelper.sh"
. "$ZAPRET_BASE/common/ipt.sh"
. "$ZAPRET_BASE/common/nft.sh"
. "$ZAPRET_BASE/common/linux_fw.sh"

[ -n "$QNUM" ] || QNUM=200
[ -n "$TPPORT" ] || TPPORT=988
[ -n "$WS_USER" ] || WS_USER=daemon
[ -n "$DESYNC_MARK" ] || DESYNC_MARK=0x40000000
[ -n "$OPENWRT_LAN" ] || OPENWRT_LAN=lan

TPWS_LOCALHOST4=127.0.0.127

# max wait time for the link local ipv6 on the LAN interface
LINKLOCAL_WAIT_SEC=5

IPSET_CR="$ZAPRET_BASE/ipset/create_ipset.sh"

CUSTOM_SCRIPT="$ZAPRET_BASE/init.d/openwrt/custom"
[ -f "$CUSTOM_SCRIPT" ] && . "$CUSTOM_SCRIPT"

IPSET_EXCLUDE="-m set ! --match-set nozapret"
IPSET_EXCLUDE6="-m set ! --match-set nozapret6"

NFQWS_OPT_DESYNC_HTTP="${NFQWS_OPT_DESYNC_HTTP:-$NFQWS_OPT_DESYNC}"
NFQWS_OPT_DESYNC_HTTPS="${NFQWS_OPT_DESYNC_HTTPS:-$NFQWS_OPT_DESYNC}"
NFQWS_OPT_DESYNC_HTTP6="${NFQWS_OPT_DESYNC_HTTP6:-$NFQWS_OPT_DESYNC_HTTP}"
NFQWS_OPT_DESYNC_HTTPS6="${NFQWS_OPT_DESYNC_HTTPS6:-$NFQWS_OPT_DESYNC_HTTPS}"



# can be multiple ipv6 outgoing interfaces
# uplink from isp, tunnelbroker, vpn, ...
# want them all. who knows what's the real one that blocks sites
# dont want any manual configuration - want to do it automatically
# standard network_find_wan[6] return only the first
# we use low level function from network.sh to avoid this limitation
# it can change theoretically and stop working

network_find_wan_all()
{
	__network_ifstatus "$1" "" "[@.route[@.target='0.0.0.0' && !@.table]].interface" "" 10 2>/dev/null && return
	network_find_wan $1
}
network_find_wan6_all()
{
	__network_ifstatus "$1" "" "[@.route[@.target='::' && !@.table]].interface" "" 10 2>/dev/null && return
	network_find_wan6 $1
}

route_localnet()
{
	for lan in $OPENWRT_LAN; do
		network_get_device DEVICE $lan
		[ -n "$DEVICE" ] || continue
		sysctl -qw net.ipv4.conf.$DEVICE.route_localnet=1
	done
}

dnat6_target()
{
	# $1 - lan network name
	# $2 - var to store target ip6
	# get target ip address for DNAT. prefer link locals
	# tpws should be as inaccessible from outside as possible
	# link local address can appear not immediately after ifup
	# DNAT6_TARGET=- means attempt was made but address was not found (to avoid multiple re-attempts)

	local DNAT6_TARGET DVAR=DNAT6_TARGET_$1
	DVAR=$(echo $DVAR | sed 's/[^a-zA-Z0-9_]/_/g')
	eval DNAT6_TARGET="\$$DVAR"
	[ -n "$2" ] && eval $2=''
 
	[ -n "$DNAT6_TARGET" ] || {
		# no reason to query if its down
		network_is_up $1 || return

		local DEVICE
		network_get_device DEVICE $1

		local ct=0
		while 
			DNAT6_TARGET=$(get_ipv6_linklocal $DEVICE)
			[ -n "$DNAT6_TARGET" ] && break
			[ "$ct" -ge "$LINKLOCAL_WAIT_SEC" ] && break
			echo $DEVICE: waiting for the link local for another $(($LINKLOCAL_WAIT_SEC - $ct)) seconds ...
			ct=$(($ct+1))
			sleep 1
		do :; done

		[ -n "$DNAT6_TARGET" ] || {
			echo $DEVICE: no link local. getting global
			DNAT6_TARGET=$(get_ipv6_global $DEVICE)
			[ -n "$DNAT6_TARGET" ] || {
				echo $DEVICE: could not get any address
				DNAT6_TARGET=-
			}
		}
		eval $DVAR="$DNAT6_TARGET"
	}
	[ -n "$2" ] && eval $2="$DNAT6_TARGET"
}


set_route_localnet()
{
	# $1 - 1 = enable, 0 = disable

	[ "$DISABLE_IPV4" = "1" ] || {
		local lan DEVICE
		for lan in $OPENWRT_LAN; do
			network_get_device DEVICE $lan
			[ -n "$DEVICE" ] || continue
			sysctl -q -w net.ipv4.conf.$DEVICE.route_localnet=$1
		done
	}
}
prepare_route_localnet()
{
	set_route_localnet 1
}
unprepare_route_localnet()
{
	set_route_localnet 0
}
prepare_tpws_fw4()
{
	# otherwise linux kernel will treat 127.0.0.0/8 as "martian" ip and refuse routing to it
	# NOTE : kernels <3.6 do not have this feature. consider upgrading or change DNAT to REDIRECT and do not bind to 127.0.0.0/8

	[ "$DISABLE_IPV4" = "1" ] || {
		iptables -N input_rule_zapret 2>/dev/null
		ipt input_rule_zapret -d $TPWS_LOCALHOST4 -j RETURN
		ipta input_rule_zapret -d 127.0.0.0/8 -j DROP
		ipt INPUT ! -i lo -j input_rule_zapret

		prepare_route_localnet
	}
}
unprepare_tpws_fw4()
{
	[ "$DISABLE_IPV4" = "1" ] || {
		unprepare_route_localnet

		ipt_del INPUT ! -i lo -j input_rule_zapret
		iptables -F input_rule_zapret 2>/dev/null
		iptables -X input_rule_zapret 2>/dev/null
	}
}
unprepare_tpws_fw()
{
	unprepare_tpws_fw4
}

fw_nfqws_pre4()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter ipv4
	# $3 - queue number

	local DEVICE wan_iface

	[ "$DISABLE_IPV4" = "1" ] || {
		network_find_wan_all wan_iface
		for ext_iface in $wan_iface; do
			network_get_device DEVICE $ext_iface
			ipt_add_del $1 PREROUTING -t mangle -i $DEVICE -p tcp $2 $IPSET_EXCLUDE src -j NFQUEUE --queue-num $3 --queue-bypass
		done
	}
}
fw_nfqws_pre6()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter ipv6
	# $3 - queue number

	local DEVICE wan_iface

	[ "$DISABLE_IPV6" = "1" ] || {
		network_find_wan6_all wan_iface
		for ext_iface in $wan_iface; do
			network_get_device DEVICE $ext_iface
			ipt6_add_del $1 PREROUTING -t mangle -i $DEVICE -p tcp $2 $IPSET_EXCLUDE6 src -j NFQUEUE --queue-num $3 --queue-bypass
		done
	}
}
fw_nfqws_pre()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter ipv4
	# $3 - filter ipv6
	# $4 - queue number

	fw_nfqws_pre4 $1 "$2" $4
	fw_nfqws_pre6 $1 "$3" $4
}
fw_nfqws_post4()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter ipv4
	# $3 - queue number

	local DEVICE wan_iface

	[ "$DISABLE_IPV4" = "1" ] || {
		network_find_wan_all wan_iface
		for ext_iface in $wan_iface; do
			network_get_device DEVICE $ext_iface
			ipt_add_del $1 POSTROUTING -t mangle -o $DEVICE -p tcp $2 $IPSET_EXCLUDE dst -j NFQUEUE --queue-num $3 --queue-bypass
		done
	}
}
fw_nfqws_post6()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter ipv6
	# $3 - queue number

	local DEVICE wan_iface

	[ "$DISABLE_IPV6" = "1" ] || {
		network_find_wan6_all wan_iface
		for ext_iface in $wan_iface; do
			network_get_device DEVICE $ext_iface
			ipt6_add_del $1 POSTROUTING -t mangle -o $DEVICE -p tcp $2 $IPSET_EXCLUDE6 dst -j NFQUEUE --queue-num $3 --queue-bypass
		done
	}
}
fw_nfqws_post()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter ipv4
	# $3 - filter ipv6
	# $4 - queue number

	fw_nfqws_post4 $1 "$2" $4
	fw_nfqws_post6 $1 "$3" $4
}


IPT_OWNER="-m owner ! --uid-owner $WS_USER"
fw_tpws4()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter ipv4
	# $3 - tpws port

	local lan DEVICE ext_iface wan_iface
 
	[ "$DISABLE_IPV4" = "1" ] || {
		network_find_wan_all wan_iface
		for ext_iface in $wan_iface; do
			network_get_device DEVICE $ext_iface
			ipt_add_del $1 OUTPUT -t nat -o $DEVICE $IPT_OWNER -p tcp $2 $IPSET_EXCLUDE dst -j DNAT --to $TPWS_LOCALHOST4:$3
		done
		[ "$1" = 1 ] &&	prepare_tpws_fw4
		for lan in $OPENWRT_LAN; do
			network_get_device DEVICE $lan
			[ -n "$DEVICE" ] || continue
			ipt_add_del $1 PREROUTING -t nat -i $DEVICE -p tcp $2 $IPSET_EXCLUDE dst -j DNAT --to $TPWS_LOCALHOST4:$3
 		done
	}
}
fw_tpws6()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter ipv6
	# $3 - tpws port

	local lan DEVICE ext_iface wan_iface DNAT6
 
	[ "$DISABLE_IPV6" = "1" ] || {
		network_find_wan6_all wan_iface
			for ext_iface in $wan_iface; do
				network_get_device DEVICE $ext_iface
				ipt6_add_del $1 OUTPUT -t nat -o $DEVICE $IPT_OWNER -p tcp $2 $IPSET_EXCLUDE6 dst -j DNAT --to [::1]:$3
			done
 			for lan in $OPENWRT_LAN; do
				network_get_device DEVICE $lan
				[ -n "$DEVICE" ] || continue
				dnat6_target $lan DNAT6
				[ "$DNAT6" != '-' ] && ipt6_add_del $1 PREROUTING -t nat -i $DEVICE -p tcp $2 $IPSET_EXCLUDE6 dst -j DNAT --to [$DNAT6]:$3
			done
	}
}
fw_tpws()
{
 # $1 - 1 - add, 0 - del
 # $2 - filter ipv4
 # $3 - filter ipv6
 # $4 - tpws port

 fw_tpws4 $1 "$2" $4
 fw_tpws6 $1 "$3" $4
}


create_ipset()
{
	echo "Creating ip list table (firewall type $FWTYPE)"
	"$IPSET_CR" "$@"
}

list_nfqws_rules()
{
	# $1 = '' for ipv4, '6' for ipv6
	ip$1tables -S POSTROUTING -t mangle | \
		grep -E "NFQUEUE --queue-num $QNUM --queue-bypass|NFQUEUE --queue-num $(($QNUM+1)) --queue-bypass|NFQUEUE --queue-num $(($QNUM+2)) --queue-bypass|NFQUEUE --queue-num $(($QNUM+3)) --queue-bypass" | \
		sed -re 's/^-A POSTROUTING (.*) -j NFQUEUE.*$/\1/' -e "s/-m mark ! --mark $DESYNC_MARK\/$DESYNC_MARK//"
}
reverse_nfqws_rule()
{
	sed -e 's/-o /-i /g' -e 's/--dport /--sport /g' -e 's/--dports /--sports /g' -e 's/ dst$/ src/' -e 's/ dst / src /g'
}
apply_flow_offloading_enable_rule()
{
	# $1 = '' for ipv4, '6' for ipv6
	local i off='-j FLOWOFFLOAD'
	[ "$FLOWOFFLOAD" = "hardware" ] && off="$off --hw"
	i="forwarding_rule_zapret -m comment --comment zapret_traffic_offloading_enable -m conntrack --ctstate RELATED,ESTABLISHED $off"
	echo enabling ipv${1:-4} flow offloading : $i
	ip$1tables -A $i
}
apply_flow_offloading_exempt_rule()
{
	# $1 = '' for ipv4, '6' for ipv6
	local i v
	v=$1
	shift
	i="forwarding_rule_zapret $@ -m comment --comment zapret_traffic_offloading_exemption -j RETURN"
	echo applying ipv${v:-4} flow offloading exemption : $i
	ip${v}tables -A $i
}
flow_offloading_unexempt_v()
{
	ipt$1_del FORWARD -j forwarding_rule_zapret
	ip$1tables -F forwarding_rule_zapret 2>/dev/null
	ip$1tables -X forwarding_rule_zapret 2>/dev/null
}
flow_offloading_exempt_v()
{
	# $1 = '' for ipv4, '6' for ipv6

	is_ipt_flow_offload_avail $1 || return 0

	flow_offloading_unexempt_v $1

	[ "$FLOWOFFLOAD" = 'software' -o "$FLOWOFFLOAD" = 'hardware' ] && {
		ip$1tables -N forwarding_rule_zapret

		list_nfqws_rules $1 |
		while read rule; do
			apply_flow_offloading_exempt_rule "$1" $rule
		done

		list_nfqws_rules $1 | grep -v "connbytes" | reverse_nfqws_rule |
		while read rule; do
			apply_flow_offloading_exempt_rule "$1" $rule
		done
	
		apply_flow_offloading_enable_rule $1

		ipt$1 FORWARD -j forwarding_rule_zapret
	}

	return 0
}
flow_offloading_exempt()
{
	[ "$DISABLE_IPV4" = "1" ] || flow_offloading_exempt_v
	[ "$DISABLE_IPV6" = "1" ] || flow_offloading_exempt_v 6
}
flow_offloading_unexempt()
{
	[ "$DISABLE_IPV4" = "1" ] || flow_offloading_unexempt_v
	[ "$DISABLE_IPV6" = "1" ] || flow_offloading_unexempt_v 6
}


nft_fill_ifsets_overload()
{
	local script ifaces DLAN DWAN DWAN6

	call_for_multiple_items network_get_device DLAN "$OPENWRT_LAN"

	network_find_wan_all ifaces
	call_for_multiple_items network_get_device DWAN "$ifaces"

	network_find_wan6_all ifaces
	call_for_multiple_items network_get_device DWAN6 "$ifaces"

	nft_fill_ifsets "$DLAN" "$DWAN" "$DWAN6"
}

nft_fw_tpws4()
{
	# $1 - filter ipv4
	# $2 - tpws port

	[ "$DISABLE_IPV4" = "1" ] || {
		nft_add_rule dnat_output skuid != $WS_USER oifname @wanif meta l4proto tcp $1 ip daddr != @nozapret dnat ip to $TPWS_LOCALHOST4:$2
		nft_add_rule dnat_pre iifname @lanif meta l4proto tcp $1 ip daddr != @nozapret dnat ip to $TPWS_LOCALHOST4:$2
		prepare_route_localnet
	}
}
nft_fw_tpws6()
{
	# $1 - filter ipv6
	# $2 - tpws port

	local lan DEVICE DNAT6
	[ "$DISABLE_IPV6" = "1" ] || {
		nft_add_rule dnat_output skuid != $WS_USER oifname @wanif6 meta l4proto tcp $1 ip6 daddr != @nozapret6 dnat ip6 to [::1]:$2
		for lan in $OPENWRT_LAN; do
			network_get_device DEVICE $lan
			[ -n "$DEVICE" ] || continue
			dnat6_target $lan DNAT6
			[ "$DNAT6" != '-' ] && nft_add_rule dnat_pre iifname $DEVICE meta l4proto tcp $1 ip6 daddr != @nozapret6 dnat ip6 to [$DNAT6]:$2
		done
	}
}
nft_fw_tpws()
{
	# $1 - filter ipv4
	# $2 - filter ipv6
	# $3 - tpws port

	nft_fw_tpws4 "$1" $3
	nft_fw_tpws6 "$2" $3
}

nft_fw_nfqws_post4()
{
	# $1 - filter ipv4
	# $2 - queue number

	local DEVICE wan_iface rule

	[ "$DISABLE_IPV4" = "1" ] || {
		rule="oifname @wanif meta l4proto tcp $1 ip daddr != @nozapret"
		nft_add_rule postrouting $rule queue num $2 bypass
		nft_add_nfqws_flow_exempt_rule "$rule"
	}
}
nft_fw_nfqws_post6()
{
	# $1 - filter ipv6
	# $2 - queue number

	local DEVICE wan_iface rule

	[ "$DISABLE_IPV6" = "1" ] || {
		rule="oifname @wanif6 meta l4proto tcp $1 ip6 daddr != @nozapret6"
		nft_add_rule postrouting $rule queue num $2 bypass
		nft_add_nfqws_flow_exempt_rule "$rule"
	}
}
nft_fw_nfqws_post()
{
	# $1 - filter ipv4
	# $2 - filter ipv6
	# $3 - queue number

	nft_fw_nfqws_post4 "$1" $3
	nft_fw_nfqws_post6 "$2" $3
}
